"""
–ú–æ–¥—É–ª—å YouTube Downloader –¥–ª—è SwiftDevBot
–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤–∏–¥–µ–æ –∏ –∞—É–¥–∏–æ —Å YouTube –∏ –¥—Ä—É–≥–∏—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º.
"""

import os
import json
import logging
import asyncio
from aiogram import Router, types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
import yt_dlp

router = Router()
logger = logging.getLogger("youtube_downloader")
kernel_data = None
MODULE_NAME = "youtube_downloader"
DISPLAY_NAME = "YouTube Downloader üìπ"
DESCRIPTION = "–°–∫–∞—á–∏–≤–∞–µ—Ç –≤–∏–¥–µ–æ –∏ –∞—É–¥–∏–æ —Å YouTube, Facebook, Instagram –∏ –¥—Ä—É–≥–∏—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º."

# –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏–π FSM
class YoutubeStates(StatesGroup):
    waiting_for_url = State()

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
GLOBAL_PARAMETERS = {
    "max_quality": {
        "description": "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –≤–∏–¥–µ–æ (360, 720, 1080)",
        "required": False,
        "default": "720"
    }
}
USER_PARAMETERS = {
    "default_format": {
        "description": "–§–æ—Ä–º–∞—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (video/audio)",
        "required": False,
        "default": "video"
    },
    "default_quality": {
        "description": "–ö–∞—á–µ—Å—Ç–≤–æ –≤–∏–¥–µ–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (360, 720, 1080)",
        "required": False,
        "default": "720"
    }
}

def setup(data):
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–æ–¥—É–ª—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ."""
    global kernel_data
    kernel_data = data
    dp = kernel_data["dp"]
    dp.include_router(router)
    
    db = kernel_data.get("db")
    if db is None:
        logger.error("–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –≤ kernel_data['db']!")
        raise ValueError("–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞!")
    
    base_dir = kernel_data.get("base_dir", os.path.expanduser("~/SwiftDevBot"))
    asyncio.create_task(init_db(db))
    init_config(base_dir)
    logger.info(f"–ú–æ–¥—É–ª—å {DISPLAY_NAME} —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω –∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω —Å base_dir: {base_dir}")

async def init_db(db):
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü—ã –Ω–∞—Å—Ç—Ä–æ–µ–∫."""
    table_name = f"{MODULE_NAME}_config"
    await db.execute(f"""
        CREATE TABLE IF NOT EXISTS {table_name} (
            user_id INTEGER PRIMARY KEY,
            default_format TEXT,
            default_quality TEXT
        )
    """)
    await db.commit()
    logger.info(f"–¢–∞–±–ª–∏—Ü–∞ {table_name} —Å–æ–∑–¥–∞–Ω–∞")

def init_config(base_dir):
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞."""
    config_path = os.path.join(base_dir, "modules", MODULE_NAME, "config.json")
    if not os.path.exists(config_path):
        os.makedirs(os.path.dirname(config_path), exist_ok=True)
        default_config = {key: info["default"] for key, info in GLOBAL_PARAMETERS.items()}
        with open(config_path, "w", encoding="utf-8") as f:
            json.dump(default_config, f, indent=4)
        logger.info(f"–°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π config.json: {config_path}")

def load_config(base_dir):
    """–ó–∞–≥—Ä—É–∑–∫–∞ –≥–ª–æ–±–∞–ª—å–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏."""
    config_path = os.path.join(base_dir, "modules", MODULE_NAME, "config.json")
    if os.path.exists(config_path):
        with open(config_path, "r", encoding="utf-8") as f:
            return json.load(f)
    return {key: info["default"] for key, info in GLOBAL_PARAMETERS.items()}

async def get_user_config(db, user_id):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫."""
    table_name = f"{MODULE_NAME}_config"
    async with db.execute(f"SELECT default_format, default_quality FROM {table_name} WHERE user_id = ?", (user_id,)) as cursor:
        row = await cursor.fetchone()
    return {"default_format": row[0], "default_quality": row[1]} if row else {}

async def set_user_config(db, user_id, config):
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫."""
    table_name = f"{MODULE_NAME}_config"
    default_format = config.get("default_format", USER_PARAMETERS["default_format"]["default"])
    default_quality = config.get("default_quality", USER_PARAMETERS["default_quality"]["default"])
    await db.execute(
        f"INSERT OR REPLACE INTO {table_name} (user_id, default_format, default_quality) VALUES (?, ?, ?)",
        (user_id, default_format, default_quality)
    )
    await db.commit()
    logger.info(f"–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –æ–±–Ω–æ–≤–ª–µ–Ω—ã: {config}")

def get_settings(kernel_data):
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –º–æ–¥—É–ª—è –¥–ª—è /sysconf."""
    base_dir = kernel_data["base_dir"]
    global_config = load_config(base_dir)
    text = (
        f"üìπ –ú–æ–¥—É–ª—å {DISPLAY_NAME}\n"
        f"–û–ø–∏—Å–∞–Ω–∏–µ: {DESCRIPTION}\n"
        "–ì–ª–æ–±–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:\n"
    )
    for param, info in GLOBAL_PARAMETERS.items():
        value = global_config.get(param, info["default"])
        text += f"  {info['description']}: {value}\n"
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=f"–ò–∑–º–µ–Ω–∏—Ç—å max_quality", callback_data=f"set_yt_max_quality")]
    ])
    return text, keyboard

async def download_file(url: str, format_type: str, quality: str = None) -> tuple[str, str]:
    """–°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ —Å –ø–æ–º–æ—â—å—é yt-dlp."""
    download_dir = os.path.join(kernel_data["base_dir"], "data", "youtube_downloads")
    os.makedirs(download_dir, exist_ok=True)
    
    ydl_opts = {
        "outtmpl": os.path.join(download_dir, "%(title)s.%(ext)s"),
        "quiet": True,
        "noplaylist": True,
    }
    
    if format_type == "video":
        ydl_opts["format"] = f"bestvideo[height<={quality}]+bestaudio/best"
        ydl_opts["merge_output_format"] = "mp4"
    elif format_type == "audio":
        ydl_opts["format"] = "bestaudio/best"
        ydl_opts["postprocessors"] = [{
            "key": "FFmpegExtractAudio",
            "preferredcodec": "mp3",
            "preferredquality": "192",
        }]
    
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info = ydl.extract_info(url, download=True)
        file_path = ydl.prepare_filename(info)
        if format_type == "audio":
            file_path = file_path.rsplit(".", 1)[0] + ".mp3"
        title = info.get("title", "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è")
        return file_path, title

@router.message(Command("yt"))
async def yt_command(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /yt."""
    args = message.text.replace("/yt", "").strip()
    if args:
        await process_url(message, args, state)
    else:
        await message.answer("üìπ –í–≤–µ–¥–∏—Ç–µ URL –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è (YouTube, Facebook, Instagram –∏ —Ç.–¥.):")
        await state.set_state(YoutubeStates.waiting_for_url)

@router.message(YoutubeStates.waiting_for_url)
async def process_url_input(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ URL."""
    url = message.text.strip()
    if not url:
        await message.answer("üìπ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π URL:")
        return
    await process_url(message, url, state)

async def process_url(message: types.Message, url: str, state: FSMContext):
    """–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –≤—ã–±–æ—Ä–∞ —Ñ–æ—Ä–º–∞—Ç–∞."""
    user_config = await get_user_config(kernel_data["db"], message.from_user.id)
    default_format = user_config.get("default_format", USER_PARAMETERS["default_format"]["default"])
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üé• –í–∏–¥–µ–æ", callback_data=f"yt_video_{url}")],
        [InlineKeyboardButton(text="üéµ –ê—É–¥–∏–æ (MP3)", callback_data=f"yt_audio_{url}")],
        [InlineKeyboardButton(text=f"‚öôÔ∏è –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é ({default_format})", callback_data=f"yt_default_{url}")]
    ])
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è:", reply_markup=keyboard)
    await state.clear()

@router.callback_query(lambda c: c.data.startswith("yt_"))
async def process_selection(callback: types.CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ —Ñ–æ—Ä–º–∞—Ç–∞ –∏ –∫–∞—á–µ—Å—Ç–≤–∞."""
    parts = callback.data.split("_")
    action = parts[1]
    user_id = callback.from_user.id
    
    user_config = await get_user_config(kernel_data["db"], user_id)
    default_format = user_config.get("default_format", USER_PARAMETERS["default_format"]["default"])
    default_quality = user_config.get("default_quality", USER_PARAMETERS["default_quality"]["default"])
    global_config = load_config(kernel_data["base_dir"])
    max_quality = global_config.get("max_quality", GLOBAL_PARAMETERS["max_quality"]["default"])
    
    if action == "default":
        url = "_".join(parts[2:])
        format_type = default_format
        quality = default_quality if format_type == "video" else None
        quality_num = int(quality) if quality else 0
        max_quality_num = int(max_quality)
        if format_type == "video" and quality_num > max_quality_num:
            quality = max_quality
        await callback.message.edit_text(f"‚è≥ –°–∫–∞—á–∏–≤–∞—é ({format_type}{' ' + quality + 'p' if quality else ''})...")
        await process_download(callback.message, url, format_type, quality)
    
    elif action == "video":
        url = "_".join(parts[2:])
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="360p", callback_data=f"yt_quality_360_{url}")],
            [InlineKeyboardButton(text="720p", callback_data=f"yt_quality_720_{url}")],
            [InlineKeyboardButton(text="1080p", callback_data=f"yt_quality_1080_{url}")]
        ])
        await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—á–µ—Å—Ç–≤–æ –≤–∏–¥–µ–æ:", reply_markup=keyboard)
    
    elif action == "audio":
        url = "_".join(parts[2:])
        await callback.message.edit_text("‚è≥ –°–∫–∞—á–∏–≤–∞—é –∞—É–¥–∏–æ...")
        await process_download(callback.message, url, "audio", None)
    
    elif action == "quality":
        quality = parts[2]
        url = "_".join(parts[3:])
        quality_num = int(quality)
        max_quality_num = int(max_quality)
        if quality_num > max_quality_num:
            await callback.message.edit_text(f"‚ùå –ö–∞—á–µ—Å—Ç–≤–æ {quality}p –ø—Ä–µ–≤—ã—à–∞–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ ({max_quality}p).")
            return
        await callback.message.edit_text(f"‚è≥ –°–∫–∞—á–∏–≤–∞—é –≤–∏–¥–µ–æ ({quality}p)...")
        await process_download(callback.message, url, "video", quality)

@router.callback_query(lambda c: c.data.startswith("set_yt_"))
async def handle_settings_callback(callback: types.CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ –≤ /sysconf."""
    if callback.from_user.id not in kernel_data["admin_ids"]:
        await callback.answer("–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞!")
        return
    if callback.data == "set_yt_max_quality":
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="360p", callback_data="set_yt_max_quality_360")],
            [InlineKeyboardButton(text="720p", callback_data="set_yt_max_quality_720")],
            [InlineKeyboardButton(text="1080p", callback_data="set_yt_max_quality_1080")]
        ])
        await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ:", reply_markup=keyboard)
    elif callback.data.startswith("set_yt_max_quality_"):
        quality = callback.data.split("_")[-1]
        config_path = os.path.join(kernel_data["base_dir"], "modules", MODULE_NAME, "config.json")
        config = load_config(kernel_data["base_dir"])
        config["max_quality"] = quality
        with open(config_path, "w", encoding="utf-8") as f:
            json.dump(config, f, indent=4)
        text, keyboard = get_settings(kernel_data)
        await callback.message.edit_text(text, reply_markup=keyboard)
    await callback.answer()

async def process_download(message: types.Message, url: str, format_type: str, quality: str = None):
    """–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞."""
    try:
        file_path, title = await download_file(url, format_type, quality)
        file_size = os.path.getsize(file_path) / (1024 * 1024)
        
        if file_size > 50:
            await message.reply(f"‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π ({file_size:.2f} –ú–ë). –ú–∞–∫—Å–∏–º—É–º: 50 –ú–ë.")
            os.remove(file_path)
            return
        
        if format_type == "video":
            file = types.FSInputFile(file_path, filename=f"{title}.mp4")
            await message.reply_video(video=file, caption=f"üé• {title} ({quality}p)", supports_streaming=True)
        elif format_type == "audio":
            file = types.FSInputFile(file_path, filename=f"{title}.mp3")
            await message.reply_audio(audio=file, title=title, caption="üéµ –°–∫–∞—á–∞–Ω–æ")
        
        os.remove(file_path)
        logger.info(f"–§–∞–π–ª {title} ({format_type}) –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {message.from_user.id}")
    except Exception as e:
        await message.reply(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")
        logger.error(f"–û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è {url}: {e}")

def get_commands():
    """–°–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥ –º–æ–¥—É–ª—è."""
    return [
        {"command": "yt", "description": "üìπ –°–∫–∞—á–∞—Ç—å —Å YouTube, Facebook –∏ –¥—Ä.", "admin": False, "icon": "üìπ", "category": "YouTube"}
    ]

async def on_startup(data):
    """–î–µ–π—Å—Ç–≤–∏—è –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –º–æ–¥—É–ª—è."""
    logger.info(f"–ú–æ–¥—É–ª—å {DISPLAY_NAME} –∑–∞–ø—É—â–µ–Ω")

async def on_shutdown(data):
    """–î–µ–π—Å—Ç–≤–∏—è –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã –º–æ–¥—É–ª—è."""
    logger.info(f"–ú–æ–¥—É–ª—å {DISPLAY_NAME} –∑–∞–≤–µ—Ä—à—ë–Ω")